#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/RayTracing/RayTracingCommon.ush"

// Input parameters
RaytracingAccelerationStructure TLAS;
float3 SensorLocation;
float4 SensorRotation;
StructuredBuffer<float3> SampleDirections;
uint NumSamples;
float MinRange;
float MaxRange;

// Output structure matching C++
struct LidarPoint32Aligned
{
    float3 XYZ;
    float Intensity;
    uint RGB;
    uint bHit;
    uint2 Padding;
};

// Output parameters
RWStructuredBuffer<LidarPoint32Aligned> GPUScanResults;

// Ray payload
struct RayPayload
{
    float3 XYZ;
    float Intensity;
    uint RGB;
    bool bHit;
};

// Utility function to rotate a vector by a quaternion
float3 RotateVectorByQuaternion(float3 Vector, float4 Quaternion)
{
    float3 QuatVector = Quaternion.xyz;
    float QuatScalar = Quaternion.w;

    float3 CrossProduct = 2.0F * cross(QuatVector, Vector);
	
    return Vector + (QuatScalar * CrossProduct) + cross(QuatVector, CrossProduct);
}

[shader("raygeneration")]
void LidarRayGen()
{
	// Get current ray index and ensure that it is valid
    uint RayIndex = DispatchRaysIndex().x;
    if (RayIndex >= NumSamples) { return; }

	// Get the sample direction for the ray
    float3 LocalDirection = SampleDirections[RayIndex];

	// Convert the sample direction from local space to world space
    float3 WorldDirection = RotateVectorByQuaternion(LocalDirection, SensorRotation);

	// Configure the ray
    RayDesc Ray;
    Ray.Origin = SensorLocation + WorldDirection * MinRange;
    Ray.Direction = WorldDirection;
    Ray.TMin = 0.0F;
    Ray.TMax = max(0.0F, MaxRange - MinRange);
	
	// Zero-initialize the payload
    RayPayload Payload;
    Payload.XYZ = float3(0.0F, 0.0F, 0.0F);
    Payload.Intensity = 0.0F;
    Payload.RGB = 0x00000000U;
    Payload.bHit = false;

	// Trace ray
    TraceRay(TLAS, RAY_FLAG_FORCE_OPAQUE, 0xFFU, 0U, 1U, 0U, Ray, Payload);

	// Write results to output parameters
    LidarPoint32Aligned TraceResult;
    TraceResult.XYZ = Payload.XYZ;
    TraceResult.Intensity = Payload.Intensity;
    TraceResult.RGB = Payload.RGB;
    TraceResult.bHit = Payload.bHit ? 1U : 0U;
    TraceResult.Padding = uint2(0U, 0U);
	
    GPUScanResults[RayIndex] = TraceResult;
}

[shader("miss")]
void LidarMiss(inout RayPayload Payload)
{
	// Zero-initialize all values
    Payload.XYZ = float3(0.0F, 0.0F, 0.0F);
    Payload.Intensity = 0.0F;
    Payload.RGB = 0x00000000U;

	// Mark the point as a miss such that it can later be discarded
    Payload.bHit = false;
}

[shader("closesthit")]
void LidarClosestHit(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attributes)
{
	// Calculate the point of impact
    Payload.XYZ = WorldRayOrigin() + WorldRayDirection() * RayTCurrent();

	// TODO: actually calculate intensity and color
    Payload.Intensity = 0.0F;
    Payload.RGB = 0x00000000U;
	
	// Mark the point as a hit such that it is not discarded
    Payload.bHit = true;
}
