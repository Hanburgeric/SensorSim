#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/RayTracing/RayTracingCommon.ush"

// Input parameters
RaytracingAccelerationStructure TLAS;
float3 SensorLocation;
float4 SensorRotation;
StructuredBuffer<float3> SampleDirections;
uint NumSamples;
float MinRange;
float MaxRange;

// Output parameters
struct LidarPoint32Aligned
{
	float3 XYZ;
	float Intensity;
	uint RGB;
	uint bHit;
	uint2 Padding;
};
RWStructuredBuffer<LidarPoint32Aligned> RTScanResults;

// Ray payload
struct LidarPayload
{
	float3 XYZ;
	float Intensity;
	uint RGB;
	bool bHit;
};

// Utility function to rotate a vector by a quaternion
float3 RotateVectorByQuaternion(float3 Vector, float4 Quaternion)
{
	float3 QuatVector = Quaternion.xyz;
	float QuatScalar = Quaternion.w;

	float3 CrossProduct = 2.0F * cross(QuatVector, Vector);
	
	return Vector + (QuatScalar * CrossProduct) + cross(QuatVector, CrossProduct);
}

[shader("raygen")]
void LidarRayGen()
{
	// Get current ray index and ensure that it is valid
	uint RayIndex = DispatchRaysIndex().x;
	if (RayIndex >= NumSamples)
	{
		return;
	}

	// Get the sample direction for the ray
	float3 LocalDirection = SampleDirections[RayIndex];

	// Convert the sample direction from local space to world space
	float3 WorldDirection = RotateVectorByQuaternion(LocalDirection, SensorRotation);

	// Configure the ray
	RayDesc Ray;
	Ray.Origin = SensorLocation + WorldDirection * MinRange;
	Ray.Direction = WorldDirection;
	Ray.TMin = 0.0F;
	Ray.TMax = MaxRange - MinRange;
	
	// Zero-initialize the payload
	LidarPayload Payload;
	Payload.XYZ = float3(0.0F, 0.0F, 0.0F);
	Payload.Intensity = 0.0F;
	Payload.RGB = 0x00000000;
	Payload.bHit = false;

	// Trace ray
	TraceRay(TLAS, RAY_FLAG_FORCE_OPAQUE, 0xFF, 0U, 1U, 0U, Ray, Payload);

	// Write results to output parameters
	LidarPointAligned ScanResult;
	ScanResult.XYZ = Payload.XYZ;
	ScanResult.Intensity = Payload.Intensity;
	ScanResult.RGB = Payload.RGB;
	ScanResult.bHit = Payload.bHit ? 1U : 0U;
	ScanResult.Padding = uint2(0U, 0U);
	
	RTScanResults[RayIndex] = ScanResult;
}

[shader("miss")]
void LidarMiss(inout LidarPayload Payload)
{
	// Zero-initialize all values
	Payload.XYZ = float3(0.0F, 0.0F, 0.0F);
	Payload.Intensity = 0.0F;
	Payload.RGB = 0x00000000;

	// Mark the point as a miss such that it can later be discarded
	Payload.bHit = false;
}

[shader("closesthit")]
void LidarClosestHit(inout LidarPayload Payload, in BuiltInTriangleIntersectionAttributes Attributes)
{
	// Calculate the point of impact
	Payload.XYZ = WorldRayOrigin() + WorldRayDirection() * RayTCurrent();

	// TODO: actually calculate intensity and color
	Payload.Intensity = 0.0F;
	Payload.RGB = 0x00000000;
	
	// Mark the point as a hit such that it is not discarded
	Payload.bHit = true;
}
